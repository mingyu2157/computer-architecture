# Chapter04 CPU의 작동원리

## ALU 

- 레지스터를 통해 피연산자를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 제어신호를 받아들임

- 플래그 *flag* : 연산 결과에 대한 추가적인 상태 정보

  1. 부호 플래그 : 연산한 결과의 부호를 나타냄
  2. 제로 플래그 : 연산 결과가 0인지 여부를 나타냄
  3. 캐리 플래그 : 연산 결과 올림수나 빌림수가 발생했는지 나타냄
  4. 오버플로우 플래그 : 오버플로우가 발생했는지 나타냄
  5. 인터럽트 플래그 : 인터럽트가 가능한지를 나타냄
  6. 슈퍼바이저 플래그 : 커널 모드로 실행중인지, 사용자 모드로 실행중인지를 나타냄

  --> 플래그 레지스터에 저장됨

## 제어장치

- 제어신호를 내보내고 , 명령어를 해석하는 부품

- 제어신호 : 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기신호

  제어장치가 받아들이는 정보

  1. 클럭 신호 * 클럭 *clock* : 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위
  2. 해석해야 할 명령어
  3. 플래그 레지스터 속 플래그 값
  4. 시스템 버스에서 제어 버스로 전달된 제어신호

## 레지스터

- 반드시 알아야 하는 레지스터
  1. 프로그램 카운터 *PC : Program Counter* : 메모리에서 읽어 들일 명령어의 주소를 저장 (=명령어 포인터 *IP : Instructuon Pointer*)
  2. 명령어 레지스터 *IR : Instruction Resgister* : 방금 메모리에서 읽어 들인 명령어를 저장
  3. 메모리 주소 레지스터 *MAR : Memory Address Resgister* : 메모리 주소를 저장
  4. 메모리 버터 레지스터 *MBR : Memory Buffer Register* : 메모리와 주고받을 값 (데이터와 명령어)를 저장
  5. 플래그 레지스터 *flag register*: 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장
  6. 범용 레지스터 : *general purpose register* : 다양하고 일반적인 상황에서 자유롭게 사용
  7. 스택 포인터 : 스택 주소 지정 방식에 사용 (스택의 꼭대기를 가리키는 레지스터) -> 스택에 마지막으로 저장한 값의 위치 저장
  8. 베이스 레지스터 : 변위 주소 지정 방식에 사용

- 스택 주소 지정 방식 : 스택과 스택 포인터를 이용한 주소 지정 방식

  스택 영역 : 메모리 안에 스택처럼 사용할 영역

- 변위 주소 지정 방식 : 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식

  변위 주소 지정 방식을 사용하는 명령어

  | 연산코드 | 레지스터 | 오퍼랜드 |
  | :------: | :------: | :------: |

  오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라 방식이 나누어짐 

  - 상대 주소 지정 방식 *relative addressing mode* 

    오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식

    | 연산코드 | 프로그램 카운터 |  -3  |
    | :------: | :-------------: | :--: |

    -->실행하려는 명령어의 세 칸 이전 번지 명령어를 실행

    모든 코드를 실행하는 것이 아닌, 분기하여 특정 주소의 코드를 실행할 때 사용

  - 베이스 레지스터 주소 지정 방식 *base-register addressing mode*

    오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식

    | 연산 코드 | 베이스 레지스터 |  50  |
    | :-------: | :-------------: | :--: |

    --> 베이스 레지스터의 기준 주소로부터 50 만큼 떨어진 코드를 실행

## 명령어 사이클과 인터럽트

- 명령어 사이클 : 하나의 명령어를 처리하는 정형화된 흐름
- 인터럽트 : 간혹 명령어 사이클이 끊어지는 상황

### 명령어 사이클 *instruction cycle* 

- 인출 사이클 *fetch cycle* : 메모리에 있는 명령어를 CPU로 가지고 오는 단계
- 실행 사이클 *execution cycle* : CPU로 가져온 명령어를 실행하는 단계
- 간접 사이클 *indirect cycle* : 명령어를 인출하여 CPU로 가져왔음에도 메모리 접근을 한번 더 하는 단계

### 인터럽트

- 인터럽트 *interrupt* : CPU의 작업을 방해하는 신호

- 인터럽트의 종류

  1. 동기 인터럽트 *synchronous interrupts* : CPU에 의 발생하는 인터럽트

     -CPU가 실행하는 프로그래밍상의 오류와 같은 예외적인 상황에 마주쳤을 때 발생하는 인터럽트 (=예외 라고 부름)

  2. 비동기 인터럽트 *asynchronous interrupts* : 주로 입출력장치에 의해 발생하는 인터럽트

     -프린터기의 완료 알림/ 마우스, 키보드와 같은 입출력 장치의 입력 알림(=하드웨어 인터럽트 라고 부름)

  - 하드웨어 인터럽트 처리 순서
    1. 입출력 장치는 CPU에 인터럽트 요청 신호를 보냄
    2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인
    3. CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인
    4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업
    5. CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행
    6. 인터럽트 서비스 루틴 실행이 끝나면 4) 에서 백업해 둔 작업을 복수하여 실행을 재개