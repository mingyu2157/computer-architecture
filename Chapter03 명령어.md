# Chapter03 명령어

## 1. 소스코드와 명령어

### 고급언어와 저급언어

- 고급언어*high-level programming language* : 사람이 이해하고 작성하기 쉽게 만들어진 언어

  --> 대부분의 프로그래밍 언어

- 저급언어*low-level programming language* : 컴퓨터가 직접 이해하고 실행할 수 있는 언어 (명령어)
  1. 기계어*machine code*
     - 0과 1의 명령어 비트로 이루어진 언어
  2. 어셈블리어*assembly language*
     - 0과 1로 표현된 명령어(기계어)를 읽기 편한 형태로 번역한 저급 언어

### 컴파일 언어와 인터프리터 언어

- 고급 언어가 저급 언어로 변환되는 방식

  1. 컴파일 방식

     컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행 -> 목적 코드*object code*

  2. 인터프리트 방식

     소스 코드를 한 줄씩 차례로 실행

- 컴파일 언어 : 컴파일 방식으로 작동하는 프로그래밍 언어 (C언어)

  -> 소스 코드 내에서 오류를 하나라도 발견하면 해당 소스 코드는 컴파일에 실패함

- 인터프리터 언어 : 인터프리트 방식으로 작동하는 프로그래밍언어 (Python)

  -> 소스 코드 N번째 줄에 문법 오류가 있더라도 N-1 번째 줄까지는 올바르게 수행됨

## 2.  명령어의 구조

### 연산코드와 오퍼랜드

- 연산 코드*operation code* : 명령어가 수행할 연산 (연산자라고도 부름)
- 오퍼랜드*operand* : 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치 (피연산자라고도 부름)
- 연산 코드 필드 : 연산 코드가 담기는 영역
- 오퍼랜드 필드 : 오퍼랜드가 담기는 영역

**오퍼랜드**

오퍼랜드 필드에는 연산에 사용할 데이터를 직접 명시하기보다는 많은 경우 데이터가 저장된 위치를 명시함

-> 오퍼랜드 필드를 주소 필드라고 부르기도 함

- 0-주소 명령어 : 오퍼랜드가 하나도 없는 명령어
- 1-주소 명령어 : 오퍼랜드가 하나인 명령어
- 2-주소 명령어 : 오퍼랜드가 두 개인 명령어
- 3-주소 명령어 : 오퍼랜드가 세 개인 명령어

**연산 코드**

가장 기본적인 연산 코드 유형

1. 데이터 전송
   - MOVE : 데이터를 옮겨라
   - STORE : 메모리에 저장하라
   - LOAD(FETCH) : 메모리에서 CPU로 데이터를 가져와라
   - PUSH : 스택에 데이터를 저장하라
   - POP : 스택의 최상단 데이터를 가져와라
2. 산술/논리 연산
   - ADD / SUBTRACT / MULTIPLY / DIVIDE : 덧셈/ 뺄셈/곱셈/나눗셈을 수행하라
   - INCREMENT / DECREMENT : 오퍼랜드에 1을 더하라 / 오퍼랜드에 1을 빼라
   - AND / OR / NOT : AND / OR / NOT 연산을 수행하라
   - COMPARE : 두 개의 숫자 또는 TRUE / FALSE 값을 비교하라
3. 제어 흐름 변경
   - JUMP : 특정 주소로 실행 순서를 옮겨라
   - CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
   - HALT : 프로그램의 실행을 멈춰라
   - CALL : 되돌아올 주소 저장한 채 특정 주소로 실행 순서를 옮겨라
   - RETURN : CALL을 호출할 때 저장했던 주소로 돌아가라
4. 입출력 제어
   - READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽어라
   - WRITE(OUTPUT) : 특정 입출력 장치로 데이터를 써라
   - START IO : 입출력 장치를 시작하라
   - TEST IO : 입출력 장치의 상태를 확인하라

### 주소 지정 방식

유효주소 : 연산의 대상이 되는 데이터가 저장된 위치

**주소 지정 방식** : 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법

--> 유효주소를 찾는 방법

대표적인 주소 지정 방식

1. 즉시 주소 지정 방식*immediate addressing mode*

   연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식 -> 가장 간단한 형태의 주소 지정 방식

   데이터의 크기가 작아지지만 연산에 사용할 데이터를 찾는 과정이 없기 때문에 빠름

   레지스터나 변수를 상수값으로 초기화하는데 유용

   | 연산 코드 | 연산에 사용할 데이터 |
   | :-------: | :------------------: |
   |           |                      |

2. 직접 주소 지정 방식*direct addressing mode*

   오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식

   오퍼랜드 필드에서 표현할 수 있는 데이터의 크기는 즉시 주소 지정 방식 보다 커짐

   여전히 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼 줄어듬

   | 연산 코드 | 유효 주소 |
   | :-------: | :-------: |
   |           |           |

3. 간접 주소 지정 방식*indirect addressing mode*

   유효 주소의 주소를 오퍼랜드 필드에 명시

   접근할 수 있는 기억장치 주소 공간이 중앙처리장치가 한번에 접근할 수 있는 단어의 길이로 결정됨

   | 연산 코드 | 유효 주소의 주소 |
   | :-------: | :--------------: |
   |           |                  |

4. 레지스터 주소 지정 방식*register addressing mode*

   연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법

   CPU 외부에 있는 메모리에 접근하는 것보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠름

   표현할 수 있는 레지스터 크기에 제한이 생길 수 있음

   | 연산 코드 | 유효주소(레지스터) |
   | :-------: | :----------------: |
   |           |                    |

5. 레지스터 간접 주소 지정 방식*register addressing mode*

   연산에 사용할 데이터를 메모리에 저장하고, 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명시

   간접 주소 지정 방식과 비슷하지만 메모리에 접근하는 횟수가 한 번으로 줄어듦

   | 연산 코드 | 유효 주소를 저장한 레지스터 |
   | :-------: | :-------------------------: |
   |           |                             |

   ### 스택과 큐

   **스택**(stack)

   한쪽 끝이 막혀 있는 통과 같은 저장 공간 (프링글스 통?)

   나중에 저장한 데이터를 가장 먼저 빼내는 데이터 관리 방식(후입선출*LIFO*)

   - PUSH : 스택에 새로운 데이터를 저장하는 명령어
   - POP : 스택에 저장된 데이터를 꺼내는 명령어

   **큐**(queue)

   양쪽이 뚫려 있는 통과 같은 저장 공간

   가장 먼저 저장된 데이터부터 빼내는 데이터 관리 방식(선입선출FIFO)